<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-04-24 Mo 13:55 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Tutorial IC Design Basic Flow</title>
<meta name="author" content="Prof. Alberto Garcia-Ortiz, Amir Najafi" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../0_setup/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="../0_setup/src/readtheorg_theme/css/readtheorg.css"/>
<script type="text/javascript" src="../0_setup/src/lib/js/jquery.min.js"></script>
<script type="text/javascript" src="../0_setup/src/lib/js/bootstrap.min.js"></script>
<script type="text/javascript" src="../0_setup/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="../0_setup/src/readtheorg_theme/js/readtheorg.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="../../../../cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax7b8b.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Tutorial IC Design Basic Flow</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org1fdd3b4">1. Tutorial: simple design flow</a>
<ul>
<li><a href="#org4366a86">1.1. Goals</a></li>
<li><a href="#orgf22ccbb">1.2. Organise your data</a></li>
</ul>
</li>
<li><a href="#org3ce421b">2. Design the unit (RTL)</a>
<ul>
<li><a href="#org71482ba">2.1. Write the VHDL code</a></li>
<li><a href="#org61075ad">2.2. Compile the code</a></li>
</ul>
</li>
<li><a href="#org93e707f">3. Create test-bench and simulate</a></li>
<li><a href="#org62f4d14">4. Synthesize the unit</a>
<ul>
<li><a href="#orga4b5338">4.1. Setup for the synthesis</a></li>
<li><a href="#org30e9313">4.2. First synthesis</a></li>
</ul>
</li>
<li><a href="#orge310d3b">5. Simulate gate-level</a>
<ul>
<li><a href="#org605d0d8">5.1. Setup gate-level sim</a></li>
<li><a href="#orgb9c3365">5.2. Simulate with a SDF file</a></li>
<li><a href="#org4b48b17">5.3. Automatic execution</a></li>
<li><a href="#orgea49cee">5.4. Power estimation</a></li>
</ul>
</li>
<li><a href="#orga150d9b">6. Place&amp;Route</a>
<ul>
<li><a href="#org7116e10">6.1. Setup the tool</a></li>
<li><a href="#org29c5ce1">6.2. Initialize the design</a></li>
<li><a href="#org04c75a4">6.3. Floorplan</a></li>
<li><a href="#org2a38d24">6.4. Place the cells and pins</a></li>
<li><a href="#orga9cbec2">6.5. Route the design</a></li>
<li><a href="#orgcd7e32c">6.6. Verify and write result</a></li>
<li><a href="#org77ef7a9">6.7. Automatic execution</a></li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-org1fdd3b4" class="outline-2">
<h2 id="org1fdd3b4"><span class="section-number-2">1.</span> Tutorial: simple design flow</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org4366a86" class="outline-3">
<h3 id="org4366a86"><span class="section-number-3">1.1.</span> Goals</h3>
<div class="outline-text-3" id="text-1-1">
<p>
This tutorial aims to describe the design flow for
creating an IC.  The module that you are going to develop as an example is
an 8-bit adder with registered inputs and outputs; it is called
<code>my_adder</code>
</p>

<p>
In this tutorial, the design flow that you are going to
exercise includes the following steps:
</p>
<ul class="org-ul">
<li>RTL design and simulation</li>
<li>Synthesis of the RTL code to produce a netlist</li>
<li>Simulation of the gate-level netlist with back-annotated delays</li>
<li>Place and Route of the design to produce a layout</li>
</ul>

<p>
The general view of the flow is shown in the following picture:                                               
</p>

<div id="org39e7ac5" class="figure">
<p><img src="flow.png" alt="flow.png" />
</p>
</div>
</div>
</div>



<div id="outline-container-orgf22ccbb" class="outline-3">
<h3 id="orgf22ccbb"><span class="section-number-3">1.2.</span> Organise your data</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Before you start with the design flow, it is a good idea to create a
set of directories where you will put the data generated
during the design flow. All the files in the design are located in the
directory <code>my_adder</code>. Inside this directory, you need the following
subdirectories:
</p>

<ul class="org-ul">
<li><b>rtl</b>: This sub-directory will contain the VHDL files that model our
design. The files are at the Register-Transfer-Level (RTL).</li>
<li><b>tb</b>: This sub-directory will contain the VHDL files that you need
for the simulation of the design. They define the test-bench. Note
that they are not going to be synthesised.</li>
<li><b>gate</b>: This sub-directory will contain the gate-level netlist that
results out of the synthesis.</li>
<li><b>layout</b>: This sub-directory will contain the layout of the design
after the place and route process.</li>
</ul>

<p>
Open a new terminal and go to the directory where you want to work.
In that terminal, you can create the required directories executing with the following shell commands:
</p>
<div class="org-src-container">
<pre class="src src-sh">mkdir my_adder
mkdir my_adder/rtl
mkdir my_adder/tb
mkdir my_adder/gate
mkdir my_adder/layout
</pre>
</div>

<p>
It is also a good idea to create a new sub-directory for each tool that you want to use. They are:
</p>

<ul class="org-ul">
<li><b>do_sim</b>: A sub-directory for running the simulation (at the RTL and at the gate level).</li>
<li><b>do_synth</b>: A sub-directory for running the synthesis.</li>
<li><b>do_pr</b>: A sub-directory for running the place and route.</li>
</ul>

<div class="org-src-container">
<pre class="src src-sh">mkdir my_adder/do_sim
mkdir my_adder/do_synth
mkdir my_adder/do_pr
</pre>
</div>

<p>
Now that you have a clear structure for your data, you can start with the implementation.  
</p>
</div>
</div>
</div>

<div id="outline-container-org3ce421b" class="outline-2">
<h2 id="org3ce421b"><span class="section-number-2">2.</span> Design the unit (RTL)</h2>
<div class="outline-text-2" id="text-2">
<p>
The first step in the design flow is to create the RTL code of the
adder using VHDL. When you write your VHDL code, it is a good idea to
check that there are no syntactic errors. For that you have to compile
your code using a VHDL simulation tool. Let us proceed.
</p>
</div>

<div id="outline-container-org71482ba" class="outline-3">
<h3 id="org71482ba"><span class="section-number-3">2.1.</span> Write the VHDL code</h3>
<div class="outline-text-3" id="text-2-1">
<p>
You just need a text editor to write VHDL. In the terminal, go to the
directory <code>my_adder/rtl</code> and open a text editor to create the file
<code>my_adder.vhd</code>.  There are a lot of possibilities, as
<code>vim</code>, <code>nano</code>, <code>gedit</code>, etc. I would recomend you <code>emacs</code>.
</p>

<p>
In the terminal execute:
</p>
<div class="org-src-container">
<pre class="src src-sh">cd my_adder/rtl
</pre>
</div>

<p>
and then,
</p>
<div class="org-src-container">
<pre class="src src-sh">emacs my_adder.vhd &amp;
</pre>
</div>

<p>
The code can be as follows. Copy the code in the emacs buffer and save and then close it.
</p>
<div class="org-src-container">
<pre class="src src-vhdl">library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_adder is

  port (
    clk,rstn: in std_logic;
    dta,dtb : in  std_logic_vector(7 downto 0);
    dto : out std_logic_vector(7 downto 0));

end my_adder;

architecture rtl of my_adder is

  signal dta_int,dtb_int,dto_int : std_logic_vector(7 downto 0);

begin  -- architecture rtl

  -- Define the memory elements
  process (clk, rstn) is
  begin  -- process
    if rstn = '0' then                   -- asynchronous reset (active low)
       dta_int &lt;= (others=&gt;'0');
       dtb_int &lt;= (others=&gt;'0');
       dto     &lt;= (others=&gt;'0');
    elsif clk'event and clk = '1' then  -- rising clock edge
       dta_int &lt;= dta;
       dtb_int &lt;= dtb;
       dto     &lt;= dto_int;
    end if;
  end process;

  -- Define the adder
  dto_int &lt;= std_logic_vector( signed(dta_int)+signed(dtb_int) );

end architecture rtl;
</pre>
</div>
</div>
</div>

<div id="outline-container-org61075ad" class="outline-3">
<h3 id="org61075ad"><span class="section-number-3">2.2.</span> Compile the code</h3>
<div class="outline-text-3" id="text-2-2">
<p>
To ensure that your code does not have any error, you can compile it with a VHDL simulation tool.
You are going to use the tool <code>irun</code> from
Cadence. 
</p>

<p>
Before you can actually use it, you have to load the tool and to do
the setup.  You should go to the directory <code>my_adder/do_sim</code> where you
are going to run the simulation tool. In a new terminal execute:
</p>
<div class="org-src-container">
<pre class="src src-shell">cd ../do_sim
</pre>
</div>

<div class="org-src-container">
<pre class="src src-shell">setenv LM_LICENSE_FILE "28211@item0096"
source /eda/cadence/2017-18/scripts/INCISIVE_15.20.038_RHELx86.csh
</pre>
</div>

<p>
Actually, it is a good idea to create a file called <code>source.csh</code> in the
<code>my_adder/do_sim/</code> directory so that you do not have to remember the location of
the initialisation script.
</p>

<p>
Once the set-up is done, you can use the <code>irun</code> tool. To
compile the VHDL code that you wrote, execute in the terminal the following command:
</p>
<div class="org-src-container">
<pre class="src src-sh">irun -compile -v93 -access +rw   ../rtl/my_adder.vhd
</pre>
</div>
<p>
The compilation process starts, and the tool reports if there have been any error.
If you have them, you need to correct the VHDL code with the text editor. 
</p>

<p>
The options that you have used are the following:
</p>
<ul class="org-ul">
<li><b>-compile</b>: Indicates that you want to compile the code; still you do not elaborate or simulate.</li>
<li><b>-v93</b>: Indicates that you want to use the revision 1993 of VHDL. You can also use <code>-v200x</code> for that 
latest VHDL features.</li>
<li><b>-access +rw</b>: Indicates that you want to access all the signals in your design.</li>
</ul>

<p>
It is a bit inconvenient to remember the options of the <code>irun</code>
command. A better alternative is to create a file called <code>hdl.var</code> in the
<code>do_sim</code> directory with the options that you use by default. The contents of the
<code>hdl.var</code> can be as follows:
</p>
<div class="org-src-container">
<pre class="src src-sh">DEFINE IRUNOPTS  -access +rw -v93
</pre>
</div>
<p>
Observe it does not include the <code>-compile</code> because sometimes you want to use this options and sometimes not.
</p>

<p>
Now the compilation can be executed by running the simpler command:
</p>
<div class="org-src-container">
<pre class="src src-sh">irun -compile ../rtl/my_adder.vhd
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org93e707f" class="outline-2">
<h2 id="org93e707f"><span class="section-number-2">3.</span> Create test-bench and simulate</h2>
<div class="outline-text-2" id="text-3">
<p>
Now you can create a test-bench that exercise the unit. Go the the
directory <code>../tb</code> and then open a new file named
<code>my_adder_tb.vhd</code> to define the test bench. In the terminal type:
</p>

<div class="org-src-container">
<pre class="src src-shell">cd ../tb
pwd
</pre>
</div>


<p>
And open your file using for example the emacs editor:
</p>

<div class="org-src-container">
<pre class="src src-shell">emacs my_adder_tb.vhd
</pre>
</div>


<p>
The code can be as follows:
</p>
<div class="org-src-container">
<pre class="src src-vhdl">library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_adder_tb is
end entity my_adder_tb;

architecture tst of my_adder_tb is

  -- component ports
  signal dta, dtb : std_logic_vector(7 downto 0);
  signal dto      : std_logic_vector(7 downto 0);

  -- clock
  signal clk : std_logic := '1';
  signal rstn : std_logic;

begin  -- architecture tst

  -- component instantiation
  DUT: entity work.my_adder
    port map (
      clk =&gt; clk,
      rstn =&gt; rstn,
      dta =&gt; dta,
      dtb =&gt; dtb,
      dto =&gt; dto);

  -- clock generation
  clk &lt;= not clk after 1 ns;
  rstn &lt;= '0', '1' after 500 ps;

  -- waveform generation
  WaveGen_Proc: process
  begin
    dta &lt;= std_logic_vector(to_signed(3,  dta'length));
    dtb &lt;= std_logic_vector(to_signed(-1, dtb'length));    
    wait until clk = '0';
    wait until clk = '0';
    dta &lt;= std_logic_vector(to_signed(6,  dta'length));
    dtb &lt;= std_logic_vector(to_signed(1, dtb'length));    
    wait until clk = '0';
    dta &lt;= std_logic_vector(to_signed(-4,  dta'length));
    dtb &lt;= std_logic_vector(to_signed(-3, dtb'length));    
    wait until clk = '0';
    dta &lt;= std_logic_vector(to_signed(2**7-1,  dta'length));
    dtb &lt;= std_logic_vector(to_signed(1,  dtb'length));    
    wait until clk = '0';
    wait until clk = '0';

    report "End simulation" severity failure;  -- Finish
  end process WaveGen_Proc;

end architecture tst;
</pre>
</div>

<p>
Save and close the emacs. Now you can compile it to ensure that there are no errors. To do that,
you have to go to the directory <code>do_sim</code> where the simulation
tools works; there you can launch <code>irun</code> again.
</p>
<div class="org-src-container">
<pre class="src src-shell">cd ../do_sim
irun -compile ../tb/my_adder_tb.vhd
</pre>
</div>

<p>
Afterwards,  you can launch <code>irun</code> in graphical mode to simulate the testbench:
</p>
<div class="org-src-container">
<pre class="src src-sh">irun  -gui  ../tb/my_adder_tb.vhd  ../rtl/my_adder.vhd -top my_adder_tb
</pre>
</div>

<p>
The options that you have used are the following:
</p>
<ul class="org-ul">
<li><b>-gui</b>: Indicates that you want to use the graphical user interface to see the signals in a window.</li>
<li><b>-top</b> my_adder_tb: Indicates the (top) design that you want to simulate; in your case, it is the entity name of the test-bench.</li>
</ul>


<p>
Once you start the tool, you can use the <code>Design Browser</code> to select
the signals that you want to plot during simulation. For example, you
can select all the signals of the <code>DUT</code>. Click in the waveform symbol or in 
the menu <code>Windows</code> &rarr; <code>Send To</code> &rarr; <code>Waveform</code>.
</p>


<div id="org3399c13" class="figure">
<p><img src="figs/sim_browser.png" alt="sim_browser.png" />
</p>
</div>

<p>
Then you can simulate using <code>Simulation</code> &rarr; <code>Run</code>
</p>


<div id="orgfdf0691" class="figure">
<p><img src="figs/sim_results.png" alt="sim_results.png" />
</p>
</div>

<p>
It is convenient to have a script to re-run the simulation without using the GUI. You can create a
file called <code>do_sim.tcl</code> with the following content:
</p>
<div class="org-src-container">
<pre class="src src-tcl">database my_adder_tb.vcd -vcd -default
probe -create -all -depth all
run
</pre>
</div>
<p>
It will create a database in <code>vcd</code> format, add as probes all the
signals in the hierarchy and then run the test-bench.
</p>

<p>
Now you can run an automatic simulation:
</p>
<div class="org-src-container">
<pre class="src src-sh">irun   ../tb/my_adder_tb.vhd  ../rtl/my_adder.vhd  -top my_adder_tb  -input do_sim.tcl
</pre>
</div>
</div>
</div>

<div id="outline-container-org62f4d14" class="outline-2">
<h2 id="org62f4d14"><span class="section-number-2">4.</span> Synthesize the unit</h2>
<div class="outline-text-2" id="text-4">
<p>
In this part of the tutorial you are going to synthesise your
<code>my_adder</code> unit using the <code>design_vision</code> tool from Synopys,
one of the tools most commonly used in industry today for IC design.
</p>

<p>
The flow of information during synthesis can be summarised in the following figure:
</p>

<div id="org7ca8678" class="figure">
<p><img src="flow_synth.png" alt="flow_synth.png" />
</p>
</div>

<p>
The synthesis tool transforms a description of the circuit at the RTL
level (Register Transfer Level) into a netlist. Basically, the RTL code, which is
written in a hardware description language as VHDL and defines the
functionality of the unit. The netlist describes the implementation of the unit 
using digital gates from a existing library of standard cells. 
</p>

<p>
In order to perform a Synthesis the tool needs not only the
information about the timing and size of the standard cells, but also
which are the requirements for the circuit. For example, you can
specify the maximum area that you expect your implementation to use or
the speed that you target. This information, referred as constraints,
is typically given with a script written a language called <code>tcl</code>.
</p>

<p>
The main result of the synthesis process is the netlist. Furthermore, it
generate as well some reports that describe the important
characteristics of your design: area, performance, power
consumption etc.
</p>
</div>

<div id="outline-container-orga4b5338" class="outline-3">
<h3 id="orga4b5338"><span class="section-number-3">4.1.</span> Setup for the synthesis</h3>
<div class="outline-text-3" id="text-4-1">
<p>
To start the synthesis, open a <b>new</b> terminal and go to the <code>do_synth</code> directory.
</p>


<div class="org-src-container">
<pre class="src src-sh">cd my_adder/do_synth
pwd
</pre>
</div>

<p>
During the synthesis process, you are going to generate a lot of
data. Therefore, it is a good idea to organise the information in
sub-directories. You can use:
</p>

<ul class="org-ul">
<li><b>results</b>: This sub-directory contains the results of the synthesis</li>
<li><b>reports</b>: This sub-directory contains the reports generated during synthesis</li>
<li><b>cmd</b>: It contains the scipts that you can use to automatise the synthesis process</li>
<li><b>log</b>: In this sub-directory you can save of the log files generated during the synthesis process</li>
<li><b>tool</b>: In this sub-directory you can put all the intermediate files
required by the tool. Note that Once you are done with the
synthesis, you can delete this directory but not the previous ones.</li>
</ul>

<div class="org-src-container">
<pre class="src src-sh">mkdir results
mkdir reports
mkdir cmd
mkdir log
mkdir tool
</pre>
</div>

<p>
To do the set-up, we have to define the paths to the tool. Create a
file called <code>sourceme.csh</code> with the following content:
</p>
<div class="org-src-container">
<pre class="src src-shell">setenv SNPSLMD_LICENSE_FILE "28231@item0096"
setenv PATH /usrf01/prog/synopsys/syn/R-2020.09-SP4/bin:${PATH}
</pre>
</div>

<p>
Now you can source it:
</p>
<div class="org-src-container">
<pre class="src src-shell">source sourceme.csh
</pre>
</div>

<p>
Before you open the synthesis tool, it is practical to select the library of
standard cells that you use and to instruct the tool to save the log
files into the directories that you have previously defined. You can
do that creating a <code>.synopsys_dc.setup</code> file. Run <code>emacs .synopsys_dc.setup</code>.
</p>

<p>
First, you can add the following commands to your <code>.synopsys_dc.setup</code>
file; they instruct the tool to use your directories.
</p>

<div class="org-src-container">
<pre class="src src-tcl">define_design_lib work -path ./tool/work

set_app_var  view_log_file        ./log/synth_view.log
set_app_var  sh_command_log_file  ./log/synth_sh.log
set_app_var  filename_log_file    ./log/synth_file.log

set_app_var search_path       [concat ./cmd/  [get_app_var search_path] ]    
</pre>
</div>

<p>
And afterwards you can write the command to define the library to use. 
</p>

<div class="org-src-container">
<pre class="src src-tcl">set library_path "../../../0_FreePDK45/LIB"
set library_name "NangateOpenCellLibrary_typical_ccs.db"

set_app_var target_library    $library_name
set_app_var link_library      [concat $library_name dw_foundation.sldb "*"]
set_app_var search_path       [concat $library_path [get_app_var search_path] ]
set_app_var synthetic_library [list dw_foundation.sldb]
set_app_var symbol_library    [list class.sdb]

set_app_var vhdlout_use_packages { ieee.std_logic_1164.all  NangateOpenCellLibrary.Components.all }
set_app_var vhdlout_write_components FALSE
</pre>
</div>

<p>
Observe that you are using the library
<code>NangateOpenCellLibrary_typical_ccs.db</code> that contains typical delay
values. A more conservative alternative would have been to use
<code>NangateOpenCellLibrary_slow_ccs.db</code> with the worst delays.
</p>

<p>
Save  your file. Now, when the synthesis tool starts, it will use the right technology. 
</p>
<div class="note" id="org63fabe7">
<p>
<code>.db</code> extention is the synopsys library database format which is the compiled version of <code>.lib</code> file.
</p>

</div>
</div>
</div>


<div id="outline-container-org30e9313" class="outline-3">
<h3 id="org30e9313"><span class="section-number-3">4.2.</span> First synthesis</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Now you can start the tool. Launch <code>design_vision</code> in the terminal. To
save the log in a directory, you can add a linux pipe 
<code>tee log/synthesis.log</code> that redirects the log output to a file called <code>log/synthesis.log</code>. 
</p>
<div class="org-src-container">
<pre class="src src-sh">design_vision | tee log/synthesis.log &amp;
</pre>
</div>


<div id="orgb7142b4" class="figure">
<p><img src="figs/design_vision_new.png" alt="design_vision_new.png" />
</p>
</div>


<p>
Now we can start the synthesis. The first step is to read the RTL code.  In the menu select <code>File</code> &rarr;
<code>Read</code> . In the new window select the VHDL code to read, i.e., <code>../rtl/my_adder.vhd</code> and click <code>Open</code>.
</p>


<div id="org963eb22" class="figure">
<p><img src="figs/design_vision_read_new.png" alt="design_vision_read_new.png" />
</p>
</div>

<p>
Alternatively, you can  type the following command line in the <code>design_vision</code> prompt.
</p>
<div class="org-src-container">
<pre class="src src-tcl">read_file -format vhdl {../rtl/my_adder.vhd}
</pre>
</div>

<p>
The tool reads and "understands" the code. In the log file you can see
the elements that it has inferred. For example, it found the following
registers:
</p>

<pre class="example" id="orgc60c6ad">
Inferred memory devices in process
	in routine my_adder line 22 in file
		'/usrf06/home/agids/usr/agarcia/GIT/tutorial_ic_design/my_adder/rtl/my_adder.vhd'.
===============================================================================
|    Register Name    |   Type    | Width | Bus | MB | AR | AS | SR | SS | ST |
===============================================================================
|       dto_reg       | Flip-flop |   8   |  Y  | N  | Y  | N  | N  | N  | N  |
|     dta_int_reg     | Flip-flop |   8   |  Y  | N  | Y  | N  | N  | N  | N  |
|     dtb_int_reg     | Flip-flop |   8   |  Y  | N  | Y  | N  | N  | N  | N  |
===============================================================================
Presto compilation completed successfully.
</pre>


<p>
Before we compile the design, we define a set of design constraints in tool command language (Tcl).
The synthesis tool will generate a <code>.sdc</code> file (Synopsys Design Constraints) that can be given as an input to the place and route tool later on.
</p>

<p>
Copy and paste the following you can commands in the <code>design_vision</code> prompt.
</p>

<div class="org-src-container">
<pre class="src src-tcl">create_clock [get_ports clk]  -period 8.0  -waveform {0 4} -name clk

set_clock_uncertainty 0.025  -setup [get_clocks clk]
set_clock_uncertainty 0.025  -hold [get_clocks clk]
set_clock_transition -fall 0.04 [get_clocks clk]
set_clock_transition -rise 0.04 [get_clocks clk]

set_dont_touch clk
set_dont_touch rstn

set_clock_latency -max -source 0.1 [get_clocks clk] 

set_input_delay -max -clock clk  0.05 [get_ports {dta dtb}]
set_output_delay -max -clock clk  0.05 [all_outputs]

set_false_path -from [get_ports rstn]

check_timing
</pre>
</div>


<p>
Now we can map the design into gates. In the menu select <code>Design</code> &rarr; <code>Compile design...</code>. You can 
start a default synthesis by clicking <code>Apply</code> without any modification.
</p>


<div id="org342a7ce" class="figure">
<p><img src="figs/design_vision_compile_new.png" alt="design_vision_compile_new.png" />
</p>
</div>

<p>
Alternatively, you can  type the following command line in the <code>design_vision</code> prompt.
</p>
<div class="org-src-container">
<pre class="src src-tcl">compile
</pre>
</div>

<p>
If you want to see the schematic of the result, select in the menu <code>Schematic</code> &rarr; <code>New schematic view</code>. 
The result is:
</p>



<div id="org324b70f" class="figure">
<p><img src="figs/design_vision_schematic_new.png" alt="design_vision_schematic_new.png" />
</p>
</div>

<div class="NOTE" id="org50e8d0c">
<p>
Since you have not define any constraints, the tool chooses an architecture for the adder which is small in area.
</p>

</div>

<p>
Now you can check the characteristics of your design. Let us analyse
first the area requirements. In the menu select <code>Design</code> &rarr; <code>Report
Area</code>.  It is a good idea to save the reports. In the <code>design_vision</code> prompt type:
</p>

<div class="org-src-container">
<pre class="src src-tcl">report_area &gt; reports/my_adder-spl_synth.area
</pre>
</div>

<p>
As you can see in the report, most of the area is required for the noncombinational elements. 
</p>

<pre class="example" id="org86a9d56">
****************************************
Report : area
Design : my_adder
Version: K-2015.06-SP4
Date   : Fri May 25 18:49:21 2018
****************************************

Information: Updating design information... (UID-85)
Library(s) Used:

    NangateOpenCellLibrary (File: /usrf06/home/agids/usr/agarcia/GIT/tutorial_ic_design/FreePDK45/NangateOpenCellLibrary_typical_ccs.db)

Number of ports:                           52
Number of nets:                            82
Number of cells:                           35
Number of combinational cells:              9
Number of sequential cells:                25
Number of macros/black boxes:               0
Number of buf/inv:                          0
Number of references:                       2

Combinational area:                 32.452000
Buf/Inv area:                        0.000000
Noncombinational area:             127.680004
Macro/Black Box area:                0.000000
Net Interconnect area:      undefined  (Wire load has zero net area)

Total cell area:                   160.132004
Total area:                 undefined
1
</pre>

<p>
As you can see in the report, most of the area is required for the noncombinational elements.
</p>

<p>
In the same way, you can check power as follows:
</p>

<div class="org-src-container">
<pre class="src src-tcl">report_power &gt; reports/my_adder-spl_synth.power
</pre>
</div>

<p>
According to the report, the total power is 21.7887 uW.
</p>


<p>
The final step, is to save the netlist of the design with the command
<code>write_file -f vhdl</code>. Since each language (e.g. <code>vhdl</code> or <code>verilog</code>)
have some restrictions in the names of the components, it is safer to
change the names of all the elements with non-compliant names. This
can be done with the command <code>change_names</code>.  You can then execute:
</p>
<div class="org-src-container">
<pre class="src src-tcl">change_names -hier -rules vhdl 
change_names -hier -rules verilog
write_file -hierarchy -f vhdl    -output "./results/my_adder.vhd"
write_file -hierarchy -f verilog -output "./results/my_adder.v"
</pre>
</div>

<p>
If you plan to perform later on a simulation with delays, you need to
write a file with those delays. The format is called <code>sdf</code> and can be generated 
with the command <code>write_sdf</code>, for example:
</p>
<div class="org-src-container">
<pre class="src src-tcl">write_sdf  "./results/my_adder.sdf"
</pre>
</div>

<p>
In addition to the VHDL and Verilog gate-level netlists and Standard Delay Format (.sdf) file, Synopsys DC can also generate a .ddc file.
This files contains information about the gate-level netlist and timing, and using .ddc file the current state of the synthesis can be reloaded. 
This file can be generated as follows:
</p>
<div class="org-src-container">
<pre class="src src-tcl">write -hierarchy -f ddc -output  "./results/my_adder.ddc"
</pre>
</div>


<p>
Your first synthesis is done. If you want to repeat the steps, it is a
good idea to create with script with all the commands. You can create a file called
<code>cmd/do_synth_spl.tcl</code> with the following content:
</p>

<div class="org-src-container">
<pre class="src src-tcl">read_file -format vhdl {../rtl/my_adder.vhd}
create_clock [get_ports clk]  -period 8.0  -waveform {0 4} -name clk

set_clock_uncertainty 0.025  -setup [get_clocks clk]
set_clock_uncertainty 0.025  -hold [get_clocks clk]
set_clock_transition -fall 0.04 [get_clocks clk]
set_clock_transition -rise 0.04 [get_clocks clk]

set_dont_touch clk
set_dont_touch rstn

set_clock_latency -max -source 0.1 [get_clocks clk] 

set_input_delay -max -clock clk  0.05 [get_ports {dta dtb}]
set_output_delay -max -clock clk  0.05 [all_outputs]

set_false_path -from [get_ports rstn]

check_timing
compile
report_area &gt; reports/my_adder-spl_synth.area
report_power &gt; reports/my_adder-spl_synth.power
change_names -hier -rules vhdl 
change_names -hier -rules verilog
write_file -hierarchy -f vhdl    -output "./results/my_adder.vhd"
write_file -hierarchy -f verilog -output "./results/my_adder.v"
write_sdf  "./results/my_adder.sdf"
write -hierarchy -f ddc -output  "./results/my_adder.ddc"
</pre>
</div>

<p>
and then re-execute the synthesis as follows:
</p>
<div class="org-src-container">
<pre class="src src-sh">dc_shell -x "source cmd/do_synth_spl.tcl; quit"
</pre>
</div>

<p>
Once you are satisfied with the results of your synthesis, you can copy the files to the 
directory <code>gate</code> . From this directory you can take later on the final results.
</p>
<div class="org-src-container">
<pre class="src src-sh">cp results/my_adder.sdf results/my_adder.vhd  results/my_adder.v  ../gate/
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orge310d3b" class="outline-2">
<h2 id="orge310d3b"><span class="section-number-2">5.</span> Simulate gate-level</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org605d0d8" class="outline-3">
<h3 id="org605d0d8"><span class="section-number-3">5.1.</span> Setup gate-level sim</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Open a new terminal, go to the simulation directory and source the set-up file to access the simulation tools.
</p>
<div class="org-src-container">
<pre class="src src-sh">cd my_adder/do_sim
source sourceme.csh
</pre>
</div>

<p>
To simulate at the gate-level, you need the library of standard
cells; in this tutorial it is the <code>NangateOpenCellLibrary</code>. You can
create a <code>cds.lib</code> to inform the simulation tool where this library is located.
</p>

<div class="org-src-container">
<pre class="src src-lib">DEFINE nangateopencelllibrary  ../../../0_FreePDK45/VITAL/nangateopencelllibrary
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb9c3365" class="outline-3">
<h3 id="orgb9c3365"><span class="section-number-3">5.2.</span> Simulate with a SDF file</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Before you can simulate with delays, you have to compile the <code>sdf</code> file. It can be done as follows:
</p>
<div class="org-src-container">
<pre class="src src-sh">ncsdfc ../gate/my_adder.sdf  -o  my_adder.sdf.X
</pre>
</div>

<p>
Furthermore, you need to create a file to indicate the simulation tool which kind of delay (<code>maximum</code>, <code>minimum</code>, or <code>typical</code>) you want to use. Let us use
worst case delays. You should also indicate the "path" to the unit that you want to anotate, the so called <code>scope</code>. In your case, it is simply <code>:DUT</code>, as you
defined it in the <code>my_adder_tb.vhd</code> file. The <code>sdf.cmd</code> is then as follows:
</p>
<div class="org-src-container">
<pre class="src src-sdf_cmd">COMPILED_SDF_FILE = "my_adder.sdf.X",
SCOPE = :DUT,
MTM_CONTROL = "MAXIMUM",
SCALE_FACTORS = "1.0:1.0:1.0";
</pre>
</div>

<p>
You can run your test-bench, this time using a netlist with back-annotated delays:
</p>
<div class="org-src-container">
<pre class="src src-sh">irun -compile ../gate/my_adder.vhd
irun -gui ../tb/my_adder_tb.vhd  -top my_adder_tb  -sdf_cmd_file sdf.cmd 
</pre>
</div>


<div id="orgfb62eb5" class="figure">
<p><img src="figs/sim_wave_delay.png" alt="sim_wave_delay.png" />
</p>
</div>

<p>
You can observe the delay in the waveforms. For example, the cell <code>U1_1</code> has a delay between 
<code>A</code> and <code>S</code> of \(6.237-6.114=0.123\) ns. You can check in the <code>my_adder.sdf</code> file that the interconnect delay 
of the input <code>A</code> of the gate <code>U1_1</code> for a falling edge is \(0.027\) ns
</p>
<pre class="example" id="orgff0c23c">
(INTERCONNECT dta_int_regx1x/Q add_36/U1_1/A (0.026:0.028:0.028) (0.026:0.027:0.027))
</pre>
<p>
while the delay for an <code>A</code> &rarr; <code>S</code> falling transition when <code>B=0</code> and <code>C=0</code> is  \(0.096\) ns.
</p>
<pre class="example" id="orge08088a">
  (INSTANCE add_36/U1_1)
  (DELAY
    (ABSOLUTE
      .....
    (COND (B == 1'b0) &amp;&amp; (CI == 1'b0) (IOPATH A S (0.041:0.042:0.042) (0.096:0.096:0.096)))
      ......
    )
  )
)
</pre>
</div>
</div>

<div id="outline-container-org4b48b17" class="outline-3">
<h3 id="org4b48b17"><span class="section-number-3">5.3.</span> Automatic execution</h3>
<div class="outline-text-3" id="text-5-3">
<p>
It is convenient to have a script to re-run the simulation without using the GUI. You can create a
file called <code>do_sim_sdf.tcl</code> with the following content:
</p>
<div class="org-src-container">
<pre class="src src-tcl">database my_adder_tb.vcd -vcd -default
probe -create -all -depth all
run
</pre>
</div>

<p>
Now you can run an automatic simulation as follows:
</p>
<div class="org-src-container">
<pre class="src src-sh">irun ../gate/my_adder.vhd  ../tb/my_adder_tb.vhd  -top my_adder_tb  -sdf_cmd_file sdf.cmd  -input do_sim_sdf.tcl
</pre>
</div>
</div>
</div>

<div id="outline-container-orgea49cee" class="outline-3">
<h3 id="orgea49cee"><span class="section-number-3">5.4.</span> Power estimation</h3>
<div class="outline-text-3" id="text-5-4">
<p>
Power estimation requires one file with the transition activity of the nets in your design. This file, normally written in a format called 
<code>saif</code> can be generated with the <code>dumpsaif</code> command. For example, you can create the file <code>do_sim_saif.tcl</code>:
</p>
<div class="org-src-container">
<pre class="src src-tcl">dumpsaif -depth to_cells -output my_adder.saif -scope :DUT
run
</pre>
</div>
<p>
and then execute:
</p>
<div class="org-src-container">
<pre class="src src-sh">irun ../gate/my_adder.vhd  ../tb/my_adder_tb.vhd  -top my_adder_tb:tst  -sdf_cmd_file sdf.cmd -input do_sim_saif.tcl
</pre>
</div>

<p>
For example, the information about the clock is: 
</p>
<pre class="example" id="org9f3803c">
(SAIFILE
  (SAIFVERSION "2.0")
  (DIRECTION "backward")
  (DESIGN )
  (DATE "Jun 06 2018 16:53:40 CEST")
  (VENDOR "Cadence Design Systems, Inc")
  (PROGRAM_NAME "NC Simulation Engine")
  (VERSION "TOOL:       ncsim   15.20-s038")
  (DIVIDER . )
  (TIMESCALE 1 fs )
  (DURATION  11000000)
  (INSTANCE "my_adder" :DUT
     (PORT
        (clk
           (T0 5000000) (T1 6000000) (TX 0)
           (TZ 0) (TB 0) (TC 11)
        )
</pre>
<p>
Out of the total simulation time, 11000000 fs, the clock was zero
5000000 fs, one 6000000 fs and there were 11 changes in the signal.
</p>

<p>
Now that the <code>saif</code> file is created, we can get the back-annotated power report. 
To do so, we redirect to the <code>do_synth</code> directory and launch the <code>Design_vision</code> as usuall:
</p>

<div class="org-src-container">
<pre class="src src-sh">cd ../do_synth
design_vision | tee log/synthesis.log &amp;
</pre>
</div>


<div class="org-src-container">
<pre class="src src-tcl">read_file -format ddc {./results/my_adder.ddc}
</pre>
</div>


<div class="org-src-container">
<pre class="src src-tcl">read_saif -input ../do_sim/my_adder.saif -instance_name DUT -verbose
report_power &gt; reports/my_adder-post_synth.power
</pre>
</div>

<p>
The new report looks like this. 
</p>

<pre class="example" id="orga66da59">
****************************************
Report : power
        -analysis_effort low
Design : my_adder
Version: K-2015.06-SP4
Date   : Fri Apr 12 15:28:49 2019
****************************************


Library(s) Used:

    NangateOpenCellLibrary (File: /usrf06/home/agids/lab/l_ids310/FreePDK45/LIB/NangateOpenCellLibrary_typical_ccs.db)


Operating Conditions: typical   Library: NangateOpenCellLibrary
Wire Load Model Mode: top

Design        Wire Load Model            Library
------------------------------------------------
my_adder               5K_hvratio_1_1    NangateOpenCellLibrary


Global Operating Voltage = 1.1  
Power-specific unit information :
    Voltage Units = 1V
    Capacitance Units = 1.000000ff
    Time Units = 1ns
    Dynamic Power Units = 1uW    (derived from V,C,T units)
    Leakage Power Units = 1nW


  Cell Internal Power  = 124.7924 uW   (87%)
  Net Switching Power  =  18.0682 uW   (13%)
                         ---------
Total Dynamic Power    = 142.8606 uW  (100%)

Cell Leakage Power     =   2.6824 uW

Information: report_power power group summary does not include estimated clock tree power. (PWR-789)

                 Internal         Switching           Leakage            Total
Power Group      Power            Power               Power              Power   (   %    )  Attrs
--------------------------------------------------------------------------------------------------
io_pad             0.0000            0.0000            0.0000            0.0000  (   0.00%)
memory             0.0000            0.0000            0.0000            0.0000  (   0.00%)
black_box          0.0000            0.0000            0.0000            0.0000  (   0.00%)
clock_network      0.0000            0.0000            0.0000            0.0000  (   0.00%)
register           0.0000            0.0000            0.0000            0.0000  (   0.00%)
sequential       104.6088            9.9684        2.1202e+03          116.6974  (  80.18%)
combinational     20.1836            8.0998          562.2181           28.8456  (  19.82%)
--------------------------------------------------------------------------------------------------
Total            124.7924 uW        18.0682 uW     2.6824e+03 nW       145.5430 uW
</pre>

<p>
According to the report, the total power reading the saif file is 145.5430 uW.
</p>

<div class="note" id="org4f5b2f7">
<p>
If you are using <code>vsim</code> from Mentor, you can add the <code>tcl</code> commands
</p>

<pre class="example">
power add -in -inout -internal -out /my_adder_tb/DUT/*
power report -all -bsaif test.saif
</pre>

</div>
</div>
</div>
</div>

<div id="outline-container-orga150d9b" class="outline-2">
<h2 id="orga150d9b"><span class="section-number-2">6.</span> Place&amp;Route</h2>
<div class="outline-text-2" id="text-6">
<p>
The goal of the place and route is to transform the netlist into a layout. Basically, for that you have to determine the location of each single gate (placement) and to find how to connect the gates with metal wires (routing)
</p>

<p>
The steps area
</p>
<ul class="org-ul">
<li>Design initialization</li>
<li>Floorplaning</li>
<li>Placement</li>
<li>Routing</li>
<li>Export design</li>
</ul>
</div>


<div id="outline-container-org7116e10" class="outline-3">
<h3 id="org7116e10"><span class="section-number-3">6.1.</span> Setup the tool</h3>
<div class="outline-text-3" id="text-6-1">
<p>
As usual, go to the directory where you plan to run the tool (<code>do_pr</code> in this case) and create sub directories to organize the date. For example:
</p>
<div class="org-src-container">
<pre class="src src-sh">cd my_adder/do_pr
mkdir results
mkdir reports
mkdir cmd
mkdir log
mkdir tool
</pre>
</div>

<p>
For the lab you are going to use the INNOVUS tools from Cadence. Create a <code>sourceme.csh</code> file to do the setup.
</p>
<div class="org-src-container">
<pre class="src src-sh">setenv LM_LICENSE_FILE "28211@item0096"
source /eda/cadence/2017-18/scripts/INNOVUS_17.11.000_RHELx86.csh
</pre>
</div>
<p>
Now you can source that file.
</p>
<div class="org-src-container">
<pre class="src src-sh">source sourceme.csh
</pre>
</div>

<p>
Now you can start the tool
</p>
<div class="org-src-container">
<pre class="src src-sh">innovus -log log/
</pre>
</div>



<div id="orgff869d2" class="figure">
<p><img src="figs/pr_innovus.png" alt="pr_innovus.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org29c5ce1" class="outline-3">
<h3 id="org29c5ce1"><span class="section-number-3">6.2.</span> Initialize the design</h3>
<div class="outline-text-3" id="text-6-2">
<p>
Now we can read the design. In the menu execute  <code>File</code> &rarr; <code>Import Design</code>
</p>


<div id="orgb62f554" class="figure">
<p><img src="figs/pr_import.png" alt="pr_import.png" />
</p>
</div>

<p>
You have to select the verilog file to read (and the name of the top cell), the LEF files with the information about the standard cells, and the power nets of your design, i.e. <code>VDD</code> and <code>VSS</code>. Click <code>OK</code> to proceed.
</p>

<p>
Alternatively you can execute the following tcl commands:
</p>
<div class="org-src-container">
<pre class="src src-tcl">set init_lef_file ../../../0_FreePDK45/LEF/NangateOpenCellLibrary.lef
set init_gnd_net VSS
set init_pwr_net VDD

set init_verilog ../gate/my_adder.v
set init_top_cell my_adder

init_design
</pre>
</div>
</div>
</div>

<div id="outline-container-org04c75a4" class="outline-3">
<h3 id="org04c75a4"><span class="section-number-3">6.3.</span> Floorplan</h3>
<div class="outline-text-3" id="text-6-3">
<p>
The next step is to define the floorplan of your unit. In the menu select <code>Floorplan</code> &rarr; <code>Specify floorplan</code>. For example, you can select that the design should have an aspect ration of 1, a core utilization of 70% and a core to io boundary distance of 3 &mu; m in all the directions. 
</p>


<div id="orgadcfa38" class="figure">
<p><img src="figs/pr_floorplan.png" alt="pr_floorplan.png" />
</p>
</div>

<p>
Alternatively you can execute in the tcl terminal:
</p>
<div class="org-src-container">
<pre class="src src-tcl">floorPlan  -r 1 0.7 3.0 3.0 3.0 3.0
</pre>
</div>


<p>
#+ Location of pins can be set with <code>Edit</code> &rarr; <code>Pin editor</code>.
</p>
</div>
</div>

<div id="outline-container-org2a38d24" class="outline-3">
<h3 id="org2a38d24"><span class="section-number-3">6.4.</span> Place the cells and pins</h3>
<div class="outline-text-3" id="text-6-4">
<p>
Now we can place the cells. In the menu slect <code>Place</code> &rarr; <code>Place standard cells</code>  
</p>


<div id="org3c8f1c1" class="figure">
<p><img src="figs/pr_place1.png" alt="pr_place1.png" />
</p>
</div>

<p>
deselect the <code>Include Pre-Place Optimization</code> and click in <code>Mode...</code> to select additional options. In the new window you should select <code>Place IO Pins</code>. 
</p>


<div id="orgaabdb58" class="figure">
<p><img src="figs/pr_place2.png" alt="pr_place2.png" />
</p>
</div>

<div class="org-src-container">
<pre class="src src-tcl">setPlaceMode -placeIOPins 1
placeDesign -noPrePlaceOpt  
</pre>
</div>


<div class="note" id="org1abd3bc">
<p>
Since in this simple tutorial we are not using timing constraints, we are not going to generate an optimized clock tree.
</p>

</div>

<p>
Now you should insert filler cells to fill the holes in the rows. In the menu select <code>Place</code> &rarr; <code>Physical cells</code> &rarr; <code>Filler cells</code>.  Click in <code>Select</code> and select all the filler cells, then click <code>ok</code>. 
</p>


<div id="orgc7d3f32" class="figure">
<p><img src="figs/pr_filler.png" alt="pr_filler.png" />
</p>
</div>

<p>
Alternatively, you can execute the following tcl command.
</p>
<div class="org-src-container">
<pre class="src src-tcl">addFiller -cell FILLCELL_X8 FILLCELL_X4 FILLCELL_X2 FILLCELL_X1 -prefix FILLER
</pre>
</div>



<div id="orgeddee0b" class="figure">
<p><img src="figs/pr_design_placed.png" alt="pr_design_placed.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-orga9cbec2" class="outline-3">
<h3 id="orga9cbec2"><span class="section-number-3">6.5.</span> Route the design</h3>
<div class="outline-text-3" id="text-6-5">
<p>
After the placement, we can route the nets. In the menu select <code>Route</code> &rarr; <code>Nano route</code> &rarr; <code>Route</code>. 
</p>


<div id="org197d2c8" class="figure">
<p><img src="figs/pr_nanoroute.png" alt="pr_nanoroute.png" />
</p>
</div>



<p>
Alternatively, you can execute the following tcl command.
</p>
<div class="org-src-container">
<pre class="src src-tcl">routeDesign -globalDetail
</pre>
</div>


<p>
#dumpToGIF can be used to plot an image automatically
</p>


<div id="org590881e" class="figure">
<p><img src="figs/pr_design_routed.png" alt="pr_design_routed.png" />
</p>
</div>
</div>
</div>


<div id="outline-container-orgcd7e32c" class="outline-3">
<h3 id="orgcd7e32c"><span class="section-number-3">6.6.</span> Verify and write result</h3>
<div class="outline-text-3" id="text-6-6">
<p>
You can check that your design does not have errors. In the tcl terminal type:
</p>
<div class="org-src-container">
<pre class="src src-tcl">verify_drc   -report reports/my_adder.drc
verify_connectivity -report reports/my_adder.connect
</pre>
</div>


<p>
Now you can export your design into a <code>gds</code> file. <code>File</code> &rarr;  <code>Save</code> &rarr; <code>GDS/Oasis</code>.
</p>


<div id="org758dc86" class="figure">
<p><img src="figs/pr_gds.png" alt="pr_gds.png" />
</p>
</div>


<p>
Alternatively, you can execute the following tcl command.
</p>
<div class="org-src-container">
<pre class="src src-tcl">streamOut results/my_adder.gds -mapFile streamOut.map -libName my_library -units 2000 -mode ALL
</pre>
</div>
</div>
</div>

<div id="outline-container-org77ef7a9" class="outline-3">
<h3 id="org77ef7a9"><span class="section-number-3">6.7.</span> Automatic execution</h3>
<div class="outline-text-3" id="text-6-7">
<p>
Your first place and route is done. If you want to repeat the steps, it is a
good idea to create a script with all the commands. You can create a file called
<code>cmd/do_pr_spl.tcl</code> with the following content:
</p>

<div class="org-src-container">
<pre class="src src-tcl">set init_lef_file ../../../0_FreePDK45/LEF/NangateOpenCellLibrary.lef
set init_gnd_net VSS
set init_pwr_net VDD

set init_verilog ../gate/my_adder.v
set init_top_cell my_adder

init_design
floorPlan  -r 1 0.7 3.0 3.0 3.0 3.0
setPlaceMode -placeIOPins 1
placeDesign -noPrePlaceOpt  
addFiller -cell FILLCELL_X8 FILLCELL_X4 FILLCELL_X2 FILLCELL_X1 -prefix FILLER
routeDesign -globalDetail
verify_drc   -report reports/my_adder.drc
verify_connectivity -report reports/my_adder.connect
streamOut results/my_adder.gds -mapFile streamOut.map -libName my_library -units 2000 -mode ALL
</pre>
</div>

<p>
and then re-execute the process as follows:
</p>
<div class="org-src-container">
<pre class="src src-sh">innovus -log log/ -file cmd/do_pr_spl.tcl -batch 
</pre>
</div>

<p>
Once you are satisfied with the results of your place and route, you can copy the files to the 
directory <code>layout</code> . From this directory you can run the physical verification.
</p>
<div class="org-src-container">
<pre class="src src-sh">cp results/my_adder.gds ../layout
</pre>
</div>
</div>
</div>
</div>
</div>
</body>

</html>
